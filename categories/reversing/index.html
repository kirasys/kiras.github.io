<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>KiraSys</title>
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  <link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/header.png)">
        <div class='av-pic' style="background-image: url(/assets/logo.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>KiraSys</div>
        
            <div>CAT-Security</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
            <a href="/categories/" class="Btn">
              <li>Categories</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a href="https://github.com/kirasys">
                    <img src="/assets/github.svg" />
                </a>
            
        
            
                <a href="https://www.facebook.com/profile.php?id=100008635065103">
                    <img src="/assets/facebook.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ Reversing }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/02/14/CODEGATE-2018-6051/">CODEGATE 2018 - 6051</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-02-14T04:43:02.000Z" itemprop="datePublished">
    2018-02-14
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/reversing/">Reversing</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> flag[<span class="number">264</span>]; <span class="comment">// [sp+0h] [bp-118h]@1</span></span><br><span class="line">  __int64 v5; <span class="comment">// [sp+108h] [bp-10h]@1</span></span><br><span class="line"></span><br><span class="line">  v5 = *MK_FP(__FS__, <span class="number">40L</span>L);</span><br><span class="line">  <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"input : "</span>, a3);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  flag[(read(<span class="number">0</span>, flag, <span class="number">0x100</span>uLL) - <span class="number">1</span>)] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( check(flag) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"correct"</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"wrong"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag를 입력하면 correct 혹은 wrong을 출력해주는 아주 간단한 프로그램이다. check 함수에서 진행되는 검사 루틴을 분석해보면</p>
<ol>
<li>입력한 문자열을 2진수 문자열로 변환한다. 그 다음부터는 2진수 문자열을 숫자처럼 사용한다.</li>
<li>ror 연산과 비슷하게 문자열을 1byte씩 오른쪽으로 회전시켜 다시 원래의 문자열로 돌아오기 전까지 모두 테이블에 추가한다. </li>
<li>테이블에 저장된 모든 2진수 문자열을 오름 차순으로 정렬하고 문자열의 마지막 문자를 하나씩 꺼내와서 하나의 2진수의 문자열을 만든다.<br><br></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_ror</span><span class="params">(result,i)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> result[-i:] + result[:-i]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(mystr)</span>:</span></span><br><span class="line">	result = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> mystr:</span><br><span class="line">		result += bin(ord(i))[<span class="number">2</span>:].rjust(<span class="number">8</span>,<span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line">	bintable = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(result)):</span><br><span class="line">		bintable.append(int(string_ror(result,i),<span class="number">2</span>))</span><br><span class="line">	</span><br><span class="line">	bintable.sort()</span><br><span class="line">	enc = <span class="string">''</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> bintable:</span><br><span class="line">		enc += bin(i)[<span class="number">-1</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> enc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="keyword">print</span> encrypt(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>
<p>여기까지의 연산을 파이썬으로 표현하면 위와 같다. 마지막에는 압축 알고리즘을 통해 최종적으로 만들어진 2진수 문자열을 압축한 뒤, 특정 값과 비교한다.<br><br><br></p>
<h3 id="Decompress"><a href="#Decompress" class="headerlink" title="Decompress"></a>Decompress</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from ctypes import *</span><br><span class="line"></span><br><span class="line">clib = cdll.LoadLibrary(&apos;libc.so.6&apos;)</span><br><span class="line">final_table = [0x16,0xC5, ... ,0xC5,0xD4]</span><br><span class="line">SBOX = [0x63,0x7C, ... ,0xD0,0x7F]</span><br><span class="line"></span><br><span class="line">rand_table = []</span><br><span class="line">for i in range(460):</span><br><span class="line">	rand_table.append(clib.rand()&amp;0xff)</span><br><span class="line"></span><br><span class="line">decompress_bin = &apos;&apos;</span><br><span class="line">while final_table != []:</span><br><span class="line">	cur = final_table.pop(0)</span><br><span class="line">	if cur == 0x16:</span><br><span class="line">		cur2 = final_table.pop(0)</span><br><span class="line">		cur3 = final_table.pop(0)</span><br><span class="line">		</span><br><span class="line">		n = SBOX.index(cur2)</span><br><span class="line">		decompress_bin += chr((cur3 + 0x30 - rand_table.pop(0))&amp;0xff)*n</span><br><span class="line">	else:</span><br><span class="line">		decompress_bin += chr(cur + 0x30 - rand_table.pop(0))</span><br><span class="line"></span><br><span class="line">print decompress_bin</span><br></pre></td></tr></table></figure>
<p>압축 알고리즘은 간단하다. SBOX를 이용해 중복되는 데이터의 개수를 기록하는 방식으로 압축된다. 파이썬 스크립트를 통해 압축 해제하면 2진수 문자열을 구할 수 있는데, 이 2진수 문자열은 정렬된 문자열의 마지막 바이트라서 원래대로 돌리기 불가능해 보인다. 그런데 ror 연산으로 만들어진 문자열들의 마지막 바이트라는 점을 이용하면 원래의 문자열을 구할 수 있다. 예를 들어 압축 해제한 2진수 문자열이 ‘1111100’ 일때 원래의 문자열을 구해보자.<br><br><br></p>
<h3 id="Find-plain-text"><a href="#Find-plain-text" class="headerlink" title="Find plain text"></a>Find plain text</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">******1      0*****1</span><br><span class="line">******1      0*****1</span><br><span class="line">******1      1*****1</span><br><span class="line">******1  -&gt; 1*****1</span><br><span class="line">******1      1*****1</span><br><span class="line">******0      1*****0</span><br><span class="line">******0      1*****0</span><br></pre></td></tr></table></figure>
<p>오름 차순으로 정렬된 문자열이 저장된 테이블은 위와 같다. 우리는 각 요소의 마지막 비트만 알고 있지만 테이블의 모든 요소들은 ror 연산으로 만들어지기 때문에, 마지막 비트가 회전되어 첫 번째 비트로 간다. 따라서 마지막 비트들을 오름 차순으로 정렬하여 각 요소의 첫 번째 비트를 구할 수 있다.<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0*****1      01****1</span><br><span class="line">0*****1      11****1</span><br><span class="line">1*****1      10****1</span><br><span class="line">1*****1  -&gt; 10****1</span><br><span class="line">1*****1      11****1</span><br><span class="line">1*****0      11****1</span><br><span class="line">1*****0      11****1</span><br></pre></td></tr></table></figure></p>
<p>역시 ror 연산을 통해 만들어진 원형 문자열이라는 점을 이용해, 우리가 위에서 구한 길이가 2인 원형 문자열을 다시 오름 차순으로 정렬하여 2번째 비트를 구할 수 있다. 이 방식을 반복하면 정렬된 2진수 문자열 테이블을 구할 수 있고, 그 중에는 flag가 있을 것이다.<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">string_ror</span><span class="params">(result,i)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> result[-i:] + result[:-i]</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'result.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line">rbin = <span class="string">'1111111...000000'</span></span><br><span class="line">rlist = [i <span class="keyword">for</span> i <span class="keyword">in</span> rbin]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(rlist[<span class="number">0</span>]) != len(rbin):</span><br><span class="line">	rlist2 = rlist[:]</span><br><span class="line">	rlist2.sort()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(rlist2)):</span><br><span class="line">		rlist[i] += rlist2[i][<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rlist:</span><br><span class="line">	f.write(bintostr(i)+<span class="string">'\r\n'</span>)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p>
<p>result.txt를 확인해보면 FLAG{w0w_w0w_w0w_s1mp13_str1n9_c0mpr3ss10n_1011110100011}를 발견할 수 있다.</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/02/09/CODEGATE-2018-Boom/">CODEGATE 2018 - Boom</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-02-08T15:47:47.000Z" itemprop="datePublished">
    2018-02-09
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/reversing/">Reversing</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h3><p>문제에서 준 파일은 rust라는 언어로 만들어진 프로그램이다. hex-ray로 디컴 파일된 소스를 확인해보았더니 c나 c++보다 좀 더 복잡하고 분석하기 까다로웠다. 사실 이 문제를 처음 풀때는 어떻게 접근해야 될 지 몰라서 처음부터 막 분석하기 시작해서 푸는데 좀 더 오래 걸렸던 것 같다. <br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fmt_arguments(&amp;a2[<span class="number">1</span>], &amp;aEnter_this);</span><br><span class="line">cprintf();</span><br><span class="line"><span class="built_in">std</span>::process::<span class="built_in">exit</span>::h24f524da56e24372();</span><br></pre></td></tr></table></figure></p>
<p>무작정 분석하다보면 flag를 출력하는 부분을 보게 될 거라고 생각해서 프로그램의 처음부터 그냥 분석했는데, flag를 찾지 못해서 print 함수의 레퍼런스를 찾아봤다. “Enter this” 라는 문자열을 출력하는 부분이 있었고, 이 문자열이 출력되기 위해서 여러 개의 조건들을 통과해야 하는 걸보니 flag 출력이 맞다고 확신했다.</p>
<p>main 함수에서는 main::func1 함수를 실행시키고, 그 후부터는 입력값에 따라서 func2 ~ func7로 이동하였다. func1 ~ func7은 모두 입력을 받고 입력 값이 올바른지 확인후에 다른 함수로 분기하는 과정을 실행한다. 그래서 처음에는 func1 ~ func7에서 입력 값을 검사하는 루틴을 전부 분석하였는데 flag를 출력해주는 부분을 찾지 못했다. 알고보니 func1,func2,func4 ~ func6에서 입력 값이 올바르지 않을때에 func8을 실행하는데, func8 함수에서 실행하는 func11 함수에서 flag를 출력해주는 부분이 있었다. func1 ~ func7에서 입력값이 유효할 때 /tmp/files 에서 특정한 파일을 읽어 리스트에 저장하는데 이 값이 flag로 사용되었다. 그래서 flag를 알아내려면 입력값 검사 루틴을 무조건 분석해야한다.<br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// condition 1</span></span><br><span class="line">LODWORD(v2) = LinkedList_len(rsi0);</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// condition 2</span></span><br><span class="line">  v45 = <span class="number">13</span> * v44 ^ <span class="number">0x11</span>;</span><br><span class="line">      v46 = &amp;v45;</span><br><span class="line">      LODWORD(v3) = list_iter(&amp;v38);</span><br><span class="line">      v47 = v3;</span><br><span class="line">      <span class="keyword">if</span> ( core_cmp(&amp;v46, &amp;v47) &amp; <span class="number">1</span> )</span><br><span class="line">        main::func9::h0a15ac6c05fddc27();</span><br></pre></td></tr></table></figure></p>
<p>flag를 출력 시켜주는 조건은 위와 같다. Linkedlist의 길이가 4이며 리스트에 값을 꺼내와서 특정 값과 비교한다. 그 값은 0x11, 0x1c, 0xb, 0x36 이였고 이 값들이 무엇을 의미하는지 알아보았다.<br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main::func1</span></span><br><span class="line">    push_back(a2, <span class="number">0x11</span>, v21, v22, v23);</span><br><span class="line">    v71 = <span class="number">0</span>;</span><br><span class="line">    v57 = *(a1 + <span class="number">16</span>);</span><br><span class="line">    v56 = *a1;</span><br><span class="line">    v72 = <span class="number">0</span>;</span><br><span class="line">    v59 = *(a2 + <span class="number">16</span>);</span><br><span class="line">    v58 = *a2;</span><br><span class="line">    v24 = main::func3::h70b687fbcc510fb0(&amp;v56, &amp;v58);</span><br><span class="line">    v14 = core::ptr::drop_in_place::hadd5eb8b6bbe8550(v24, &amp;v53);</span><br></pre></td></tr></table></figure></p>
<p>func1~func7에서 입력받은 값이 유효해 다른 함수로 분기할 때, 특정 값을 리스트에 push한다. 이 리스트가 flag를 검사할 때 사용되는 리스트였고 위에서 구한 값들이 어떤 함수인지 알아보니 각각 func1, func2, func7, func5 였다. 이 4개의 함수를 실행시키고 func4에서 잘못된 값을 입력해 func8로 넘어가면 된다.<br><br><br></p>
<h3 id="main-fucn1-gt-main-func2"><a href="#main-fucn1-gt-main-func2" class="headerlink" title="main::fucn1 -&gt; main::func2"></a>main::fucn1 -&gt; main::func2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">std::io::stdio::Stdin::read_line::h0236420efe963fc6();</span><br><span class="line">  core::ptr::drop_in_place::h6715ef653ddd4421(&amp;v43, &amp;v44);</span><br><span class="line">  core::ptr::drop_in_place::h0c5d8ab0d3960ce8(&amp;v44);</span><br><span class="line">  LODWORD(v3) = alloc::string::String::pop::h2949ec2fec1fff2c(&amp;v42);</span><br><span class="line">  v74 = v3;</span><br><span class="line">  v45 = v3;</span><br><span class="line">  if ( core_strcmp(&amp;v42, &amp;v36) &amp; 1 )</span><br><span class="line">  &#123;</span><br></pre></td></tr></table></figure>
<p>단순히 문자열을 입력받아 비교하는 연산이다. input : ‘Know what? It’s a new day~’<br></p>
<h3 id="main-func2-gt-main-func7"><a href="#main-func2-gt-main-func7" class="headerlink" title="main::func2 -&gt; main::func7"></a>main::func2 -&gt; main::func7</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v18 = main::func10::hd8e1c12a44dfcdac(*(&amp;v72 + i), <span class="number">3L</span>L);</span><br><span class="line">v19 = main::func10::hd8e1c12a44dfcdac(v18 ^ <span class="number">0x62</span>u, <span class="number">5L</span>L);</span><br><span class="line">v58 = main::func10::hd8e1c12a44dfcdac(v19 ^ <span class="number">0x32</span>u, <span class="number">7L</span>L);</span><br><span class="line"><span class="keyword">if</span> ( i &gt;= <span class="number">7</span> )</span><br><span class="line">  core::panicking::panic_bounds_check::hbb625994aed54df2();</span><br><span class="line">*(&amp;v72 + i) = v58;</span><br><span class="line"><span class="keyword">if</span> ( i &gt;= <span class="number">7</span> )</span><br><span class="line">  core::panicking::panic_bounds_check::hbb625994aed54df2();</span><br><span class="line"><span class="keyword">if</span> ( i &gt;= <span class="number">7</span> )</span><br><span class="line">  core::panicking::panic_bounds_check::hbb625994aed54df2();</span><br><span class="line">*(&amp;v72 + i) %= <span class="number">47</span>;</span><br></pre></td></tr></table></figure>
<p>func2에서는 7개의 정수를 입력받고 그 정수로 간단한 xor 연산을 거친 후에 문자열과 비교하여 func4,func5 혹은 func7로 이동한다.<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">table = <span class="string">'f7*zq5$ase0t6ui#^yd2owgb_n8pu4!k&amp;vc@lrj19mx3h0:main.rs'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bitenc</span><span class="params">(a1,a2)</span>:</span></span><br><span class="line">	v4 = <span class="number">32</span> - a2</span><br><span class="line">	v3 = <span class="number">32</span> - a2</span><br><span class="line">	<span class="keyword">return</span> ((a1 &lt;&lt; (v3 &amp; <span class="number">0x1F</span>)) | ~(<span class="number">-1</span> &lt;&lt; (v4 &amp; <span class="number">0x1F</span>)) &amp; (a1 &gt;&gt; (a2 &amp; <span class="number">0x1F</span>)))&amp;<span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(v)</span>:</span></span><br><span class="line">	v1 = bitenc(v,<span class="number">3</span>)</span><br><span class="line">	v1 = bitenc(v1^<span class="number">0x62</span>,<span class="number">5</span>);</span><br><span class="line">	v1 = bitenc(v1^<span class="number">0x32</span>,<span class="number">7</span>) % <span class="number">47</span>;</span><br><span class="line">	<span class="keyword">return</span> table[v1]</span><br><span class="line"></span><br><span class="line">key = <span class="string">'pand0ra'</span> <span class="comment"># for going to func7</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(key)):</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0x20</span>,<span class="number">0x7f</span>):</span><br><span class="line">		<span class="keyword">if</span> key[i] == enc(j):</span><br><span class="line">			<span class="keyword">print</span> j,</span><br><span class="line">			<span class="keyword">break</span></span><br></pre></td></tr></table></figure></p>
<p>input : ‘57 93 38 92 50 86 93’ <br></p>
<h3 id="main-func7-gt-main-func5"><a href="#main-func7-gt-main-func5" class="headerlink" title="main::func7 -&gt; main::func5"></a>main::func7 -&gt; main::func5</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// condition 1</span></span><br><span class="line">  LODWORD(v6) = len(&amp;v78);</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="number">25L</span>L )</span><br><span class="line">    main::func9::h0a15ac6c05fddc27();</span><br><span class="line"></span><br><span class="line"><span class="comment">// condition 2</span></span><br><span class="line">  <span class="keyword">if</span> ( v36 != *(&amp;v44 + <span class="number">5</span> * v39 + v38) )</span><br><span class="line">    main::func9::h0a15ac6c05fddc27();</span><br></pre></td></tr></table></figure>
<p>func7 에서는 25개의 정수를 입력받아서 테이블에 있는 값과 비교한다. input : ‘17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9’<br></p>
<h3 id="main-func5-gt-main-func4"><a href="#main-func5-gt-main-func4" class="headerlink" title="main::func5 -&gt; main::func4"></a>main::func5 -&gt; main::func4</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( main::func12::h2c7664a1999a9c74(<span class="number">0</span>, v14) != <span class="number">0x6B</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v48 = <span class="number">0</span>;</span><br><span class="line">  v45 = *(a1 + <span class="number">16</span>);</span><br><span class="line">  v44 = *a1;</span><br><span class="line">  v49 = <span class="number">0</span>;</span><br><span class="line">  v47 = *(v27 + <span class="number">16</span>);</span><br><span class="line">  v46 = *v27;</span><br><span class="line">  main::func8::h2f4dc8e7bc6e464b(&amp;v44, &amp;v46);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>func5 에서는 정수 1개를 입력받아 func12에서 연산을 진행하는데, func12의 루틴은 분석하기 복잡해서 그냥 브루트 포싱으로 찾았다.<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kira <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">0xffffff</span>):</span><br><span class="line">	s = process(<span class="string">'/root/boom'</span>)</span><br><span class="line"></span><br><span class="line">	s.recvuntil(<span class="string">'mission\n'</span>)</span><br><span class="line">	s.sendline(<span class="string">'Know what? It\'s a new day~'</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.sendline(<span class="string">'57 93 38 92 50 86 93'</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.sendline(<span class="string">'17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9'</span>)</span><br><span class="line">	s.recv(<span class="number">1024</span>)</span><br><span class="line">	s.sendline(str(i))</span><br><span class="line">	res = s.recv(<span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">if</span> res.find(<span class="string">'BOO'</span>)&lt;<span class="number">0</span> <span class="keyword">and</span> res.find(<span class="string">'thread'</span>)&lt;<span class="number">0</span>:</span><br><span class="line">		<span class="keyword">print</span> key</span><br><span class="line">		<span class="keyword">print</span> res</span><br><span class="line">		raw_input(<span class="string">'w'</span>)</span><br><span class="line">	s.close()</span><br></pre></td></tr></table></figure></p>
<p>input : ‘31’<br></p>
<h3 id="Get-flag"><a href="#Get-flag" class="headerlink" title="Get flag"></a>Get flag</h3><p>위의 4개의 함수를 모두 통과하면 func4로 오게 된다. func4는 4개의 정수를 입력받고 검사하지만, func8로 이동하기 위해 올바르지 않은 값을 입력하여 func8로 이동하면 flag을 얻을 수 있다. input : ‘1 1 1 1’<br><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ./boom </span></span><br><span class="line">Welcome! You have to remove this bomb.</span><br><span class="line">Here<span class="string">'s the first mission</span></span><br><span class="line"><span class="string">Know what? It'</span>s a new day~</span><br><span class="line">Good job. Next one is~</span><br><span class="line">57 93 38 92 50 86 93</span><br><span class="line">Wowww</span><br><span class="line">17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9</span><br><span class="line">You did very well :)</span><br><span class="line">31</span><br><span class="line">GoGo!</span><br><span class="line">1 1 1 1</span><br><span class="line">Enter This! 12345678123456781234567812345678</span><br></pre></td></tr></table></figure></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/02/05/AceBear-Security-Contest-2018-Hackspeed/">AceBear Security Contest 2018 - Hackspeed</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-02-05T08:17:06.000Z" itemprop="datePublished">
    2018-02-05
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/reversing/">Reversing</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h3><p>Password를 입력받아 검사후 결과를 출력해주는 간단한 프로그램이다. 먼저 IDA를 통해 Password 검사 루틴을 분석하였다. 검사를 진행하는 함수는 hex-ray가 작동하지 않아서 어셈블리를 통해 분석해야했다.<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:01391573                 mov     edx, dword_1395408</span><br><span class="line">.text:01391579</span><br><span class="line">.text:01391579 loc_1391579:                            ; CODE XREF: sub_1391480+E0</span><br><span class="line">.text:01391579                 inc     esi</span><br><span class="line">.text:0139157A                 cmp     esi, dword_1395428</span><br><span class="line">.text:01391580                 jl      short loc_1391533</span><br><span class="line">.text:01391582                 pop     edi</span><br><span class="line">.text:01391583</span><br><span class="line">.text:01391583 loc_1391583:                            ; CODE XREF: sub_1391480+B0</span><br><span class="line">.text:01391583                 pop     esi</span><br><span class="line">.text:01391584                 test    edx, edx</span><br><span class="line">.text:01391586                 jz      short loc_13915AE</span><br><span class="line">.text:01391588                 mov     ecx, [edx+4]</span><br><span class="line">.text:0139158B                 call    sub_1391090</span><br><span class="line">.text:01391590                 mov     ecx, [edx+8]</span><br><span class="line">.text:01391593                 call    sub_1391090</span><br></pre></td></tr></table></figure></p>
<p>입력받은 Password를 tree 형태로 만드는데, Password의 첫 번째 글자가 최상위 노드가 되고, 두 번째 글자부터는 부모 노드와 값을 비교하여 작으면 왼쪽 노드가 되고, 크면 오른쪽 노드가 된다. 결국 꽤 복잡한 구조로 트리화되고 왼쪽 최하위 노드부터 하나씩 꺼내와서 Password를 다시 만든다. 그렇게 만들어진 Password를 다시 원래대로 돌리는것은 매우 힘들어보였다.<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:013915AE                 mov     eax, Tree_password</span><br><span class="line">.text:013915B3                 mov     ecx, Tree_password+4</span><br><span class="line">.text:013915B9                 xor     eax, ecx</span><br><span class="line">.text:013915BB                 cmp     eax, 4</span><br><span class="line">.text:013915BE                 jnz     short fail</span><br><span class="line">.text:013915C0                 mov     eax, Tree_password+8</span><br><span class="line">.text:013915C5                 xor     eax, ecx</span><br><span class="line">.text:013915C7                 cmp     eax, 7</span><br><span class="line">.text:013915CA                 jnz     short fail</span><br><span class="line">.text:013915CC                 mov     eax, Tree_password+0Ch</span><br><span class="line">.text:013915D1                 xor     eax, Tree_password+10h</span><br><span class="line">.text:013915D7                 cmp     eax, 8</span><br><span class="line">.text:013915DA                 jnz     short fail</span><br><span class="line">.text:013915DC                 mov     eax, Tree_password+14h</span><br><span class="line">.text:013915E1                 xor     eax, Tree_password+18h</span><br><span class="line">.text:013915E7                 cmp     eax, 50h</span><br></pre></td></tr></table></figure></p>
<p>재정렬된 Password를 하나씩 가져와 xor 연산으로 검사하는데, 재정렬되는 규칙이 입력 값에 따라서 매우 변칙적이라 이 정보만으로는 원래의 패스워드를 알아내기 힘들다. <br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( (Tree_password[i] ^ Table[Tree_password[i]]) == *((_BYTE *)&amp;v6 + i) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ++i &gt;= len )</span><br><span class="line">    <span class="keyword">goto</span> correct;</span><br><span class="line">&#125;</span><br><span class="line">print((<span class="keyword">int</span>)<span class="string">"Noob\n"</span>, v4);</span><br></pre></td></tr></table></figure></p>
<p>xor 연산말고 다른 함수에서 Password의 검사를 2번 진행하는데, 첫번째 함수의 검사는 위와 같다. 이 함수 덕분에 재정렬된 Password를 어느 정도 알아낼 수 있다. 예를 들어 재정렬된 Password의 첫 번째 글자가 ‘a’라고 하면 Table[‘a’] ^ v6[0]이 ‘a’가 되어야하므로 조건에 만족하는 문자를 전부 구한다음 xor 연산까지 만족하는 문자를 찾으면 될 것 같다.<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">table = [<span class="number">0x29</span>,<span class="number">0x2D</span>, ... ,<span class="number">0x67</span>,<span class="number">0x6A</span>]</span><br><span class="line">v6 = [<span class="number">0xF6</span>,<span class="number">0xE7</span>,<span class="number">0xE3</span>,<span class="number">0xF8</span>,<span class="number">0xDD</span>,<span class="number">0xE3</span>,<span class="number">0x16</span>,<span class="number">0x1D</span>,<span class="number">0xE6</span>,<span class="number">0xEC</span>,<span class="number">0xEC</span>,<span class="number">0xCC</span>,<span class="number">0xE7</span>,<span class="number">0xE0</span>,<span class="number">0xE9</span>,<span class="number">0x07</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> string.printable:</span><br><span class="line">		<span class="keyword">if</span> ord(i)^table[ord(i)] == v6[j]:</span><br><span class="line">			<span class="keyword">print</span> str(j)+<span class="string">' : '</span>+i,</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0 :  0</span></span><br><span class="line"><span class="string">1 :  4 p</span></span><br><span class="line"><span class="string">2 :  3 5</span></span><br><span class="line"><span class="string">3 :  1</span></span><br><span class="line"><span class="string">4 :  9 v :</span></span><br><span class="line"><span class="string">5 :  3 5</span></span><br><span class="line"><span class="string">6 :  e</span></span><br><span class="line"><span class="string">7 :  g</span></span><br><span class="line"><span class="string">8 :  l</span></span><br><span class="line"><span class="string">9 :  6 k r /</span></span><br><span class="line"><span class="string">10 :  6 k r /</span></span><br><span class="line"><span class="string">11 :  y =</span></span><br><span class="line"><span class="string">12 :  4 p</span></span><br><span class="line"><span class="string">13 :  m</span></span><br><span class="line"><span class="string">14 :  i</span></span><br><span class="line"><span class="string">15 :  a</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></p>
<p>가능한 문자열이 2개 이상인 경우에는 xor 연산도 만족하는 문자를 선택하면 된다. 그러면 몇 글자만 빼고 전부 알아낼 수 있다.<br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( ((<span class="keyword">unsigned</span> __int8)password[i] ^ LOBYTE(Tree_password[i])) == *((_BYTE *)&amp;v2 + i) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ++i &gt;= <span class="number">16</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Password를 검사하는 2번째 함수에서는 정렬되기 전의 Password를 연산에 사용하므로 재정렬된 Password를 통해 원래의 Password를 알아낼 수 있다. 위에서 구한 패스워드를 전부 xor해보면 flag를 구할 수 있다.<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c2 = [<span class="number">0x51</span>,<span class="number">0x01</span>,<span class="number">0x5a</span>,<span class="number">0x5c</span>,<span class="number">0x49</span>,<span class="number">0x04</span>,<span class="number">0x56</span>,<span class="number">0x0c</span>,<span class="number">0x58</span>,<span class="number">0x12</span>,<span class="number">0x1e</span>,<span class="number">0x49</span>,<span class="number">0x17</span>,<span class="number">0x54</span>,<span class="number">0x0c</span>,<span class="number">0x13</span>]</span><br><span class="line">tp = <span class="string">'043195eglkrypmia'</span></span><br><span class="line">password = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">	password += chr(ord(tp[i]) ^ c2[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> password</span><br><span class="line"><span class="comment">#output - 'a5imp13k4yl0g9er'</span></span><br></pre></td></tr></table></figure></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/02/02/AceBear-Security-Contest-2018-Secure-login/">AceBear Security Contest 2018 - Secure login</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-02-02T05:39:30.000Z" itemprop="datePublished">
    2018-02-02
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/reversing/">Reversing</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s1 = (<span class="keyword">char</span> *)generate_password((<span class="keyword">int</span>)&amp;password);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Generated password: %s\n"</span>, s1);</span><br><span class="line"> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s2) )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">"Congratulations!"</span>);</span><br><span class="line">   fd = open(<span class="string">"flag"</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> ( !fd )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">"Can not read flag! Please report this bug!"</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>nc에 접속해서 만들어지는 password를 맞추면 flag를 출력해준다. password는 rand() 값을 사용하기 때문에 같은 입력값이라도 실행마다 결과값이 변한다.<br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)nptr = *(_DWORD *)(<span class="number">4</span> * i + a1);</span><br><span class="line">    *(_DWORD *)v9 = dword_804B0C0[i];</span><br><span class="line">    v1 = strtoul(nptr, (<span class="keyword">char</span> **)nptr + <span class="number">2</span>, <span class="number">16</span>);</span><br><span class="line">    v2 = strtoul(v9, (<span class="keyword">char</span> **)v9 + <span class="number">2</span>, <span class="number">16</span>);</span><br><span class="line">    v3 = rand();</span><br><span class="line">    v6 = (<span class="keyword">unsigned</span> __int16)(v2 * ((v6 ^ v1 ^ v3) + <span class="number">1</span>) + (v6 ^ v1 ^ v3));</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)s + <span class="number">4</span> * i, <span class="string">"%04X"</span>, v6);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>위는 password를 생성하는 루틴이다. srand(time(0))와 rand를 이용하여 랜덤한 password를 생성하는 것은 python ctypes 모듈로 rand 값을 알아낼 수 있으므로 v2 값만 알아내면 되는데 v2의 값은 key라는 파일에서 읽어온다. 생성되는 password를 맞추기 위해 먼저 key 파일의 내용을 전부 알아내야 한다.<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = <span class="keyword">lambda</span> x:hex(x).replace(<span class="string">'0x'</span>,<span class="string">''</span>)</span><br><span class="line">clib = cdll.LoadLibrary(<span class="string">'/home/kirasys/slibc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">key = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">   s = remote(<span class="string">'securelogin.acebear.site'</span>,<span class="number">5001</span>)</span><br><span class="line"></span><br><span class="line">   timestamp = clib.time(<span class="number">0</span>)</span><br><span class="line">   clib.srand(int(timestamp)))</span><br><span class="line"></span><br><span class="line">   s.recvuntil(<span class="string">'Give me your name: '</span>)</span><br><span class="line">   s.sendline(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line">   s.recvuntil(<span class="string">'Gime me your password: '</span>)</span><br><span class="line">   password = <span class="string">''</span></span><br><span class="line">   </span><br><span class="line">   sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(len(key)/<span class="number">4</span> + <span class="number">1</span>):</span><br><span class="line">      v = (clib.rand() ^ sum)&amp;<span class="number">0xffff</span></span><br><span class="line">      password += e(v)</span><br><span class="line">      <span class="keyword">if</span> len(key[i*<span class="number">4</span>:i*<span class="number">4</span>+<span class="number">4</span>])==<span class="number">4</span>:</span><br><span class="line">         sum = int(key[i*<span class="number">4</span>:i*<span class="number">4</span>+<span class="number">4</span>],<span class="number">16</span>)</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">   s.sendline(password.ljust(<span class="number">64</span>,<span class="string">'1'</span>))</span><br><span class="line"></span><br><span class="line">   s.recvuntil(<span class="string">'Generated password: '</span>)</span><br><span class="line">   s.recvn(len(key))</span><br><span class="line">   key += s.recvn(<span class="number">4</span>)</span><br><span class="line">   </span><br><span class="line">   s.close()</span><br><span class="line">   <span class="keyword">if</span> len(key)&gt;=<span class="number">64</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> key</span><br></pre></td></tr></table></figure></p>
<p>v2의 값이 key 파일의 데이터이므로, (v6 ^ v1 ^ v3)을 0으로 만들어주면 생성된 password의 4byte가 key 파일의 데이터가 된다. 이런 방식으로 실행마다 4byte씩 알아낼 수 있는데 로컬과 서버의 시간이 안맞을경우 잘못된 key값이 생성될 수도 있기 때문에 여러번 실행하여 같은 결과값이 나올때가 정확한 key라고 할 수 있다.<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">key  = <span class="string">'5EDE28F84F7D5C039775B9DFFC1F85673F20C83757934BCD2FBC48868044D193'</span></span><br><span class="line">pw   = <span class="string">'F05664E983F54E5FA6D5D4FFC5BF930743F60D8FC2C78AFBB0AF7C82664F2043'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>/<span class="number">4</span>):</span><br><span class="line">	a = int(key[i*<span class="number">4</span>:i*<span class="number">4</span>+<span class="number">4</span>],<span class="number">16</span>)</span><br><span class="line">	b = BitVec(<span class="string">'b'</span>,<span class="number">16</span>)</span><br><span class="line">	</span><br><span class="line">	s = Solver()</span><br><span class="line">	s.add((a+<span class="number">1</span>)*(b+<span class="number">1</span>) == int(pw[i*<span class="number">4</span>:i*<span class="number">4</span>+<span class="number">4</span>],<span class="number">16</span>) + <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> s.check() == unsat:</span><br><span class="line">		<span class="keyword">print</span> <span class="string">"Error!!!"</span></span><br><span class="line">	m = s.model()</span><br><span class="line">	<span class="keyword">print</span> str(m[b])+<span class="string">','</span>,</span><br></pre></td></tr></table></figure></p>
<p>key 값을 전부 알아냈으면 조건에 맞게 password를 생성해주면 된다. (v6 ^ v1 ^ v3)의 값을 b라고 하고, v2의 값을 a라고 하면 a(b+1) + b = (a+1)(b+1) - 1 의 값을 특정한 값으로 만들어야 한다는 것이다. a는 고정적인 key 값이므로 z3의 BitVec을 이용하여 b의 값이 총 16번 for문을 돌면서 어떤 값이 되어야 하는지 알아낸 뒤, rand 값과 input을 그 값에 맞게 보내면 password를 특정한 값으로 만들 수 있다.<br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">KEY     = <span class="string">'5EDE28F84F7D5C039775B9DFFC1F85673F20C83757934BCD2FBC48868044D193'</span></span><br><span class="line">gen_pw  = <span class="string">'0000F05664E983F54E5FA6D5D4FFC5BF930743F60D8FC2C78AFBB0AF7C82664F2043'</span></span><br><span class="line">b = [<span class="number">13704</span>, <span class="number">41145</span>, <span class="number">21700</span>, <span class="number">11159</span>, <span class="number">9232</span>, <span class="number">215</span>, <span class="number">1005</span>, <span class="number">6916</span>, <span class="number">38934</span>, <span class="number">7741</span>, <span class="number">8905</span>, <span class="number">8913</span>, <span class="number">58991</span>, <span class="number">14116</span>, <span class="number">64015</span>, <span class="number">7228</span>]</span><br><span class="line"></span><br><span class="line">e = <span class="keyword">lambda</span> x:hex(x).replace(<span class="string">'0x'</span>,<span class="string">''</span>)</span><br><span class="line">clib = cdll.LoadLibrary(<span class="string">'libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">   s = remote(<span class="string">'securelogin.acebear.site'</span>,<span class="number">5001</span>)</span><br><span class="line"></span><br><span class="line">   timestamp = clib.time(<span class="number">0</span>)</span><br><span class="line">   clib.srand(int(timestamp))</span><br><span class="line"></span><br><span class="line">   s.recvuntil(<span class="string">'Give me your name: '</span>)</span><br><span class="line">   s.sendline(<span class="string">'name'</span>)</span><br><span class="line"></span><br><span class="line">   s.recvuntil(<span class="string">'Gime me your password: '</span>)</span><br><span class="line">   password = <span class="string">''</span></span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">64</span>/<span class="number">4</span>):</span><br><span class="line">      password += e(b[i] ^ (clib.rand()&amp;<span class="number">0xffff</span>) ^ int(gen_pw[i*<span class="number">4</span>:i*<span class="number">4</span>+<span class="number">4</span>],<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">   s.sendline(password)</span><br><span class="line">   res =  s.recv(<span class="number">1024</span>)</span><br><span class="line">   <span class="keyword">if</span> res.find(<span class="string">'Wrong'</span>)&lt;<span class="number">0</span>:</span><br><span class="line">      s.interactive()</span><br><span class="line">   </span><br><span class="line">   s.close()</span><br></pre></td></tr></table></figure></p>
<p>b의 값을 전부 알아냈으니 그걸 이용하여 패스워드를 생성하여 보내주면 된다.</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/01/24/Hack-lu-CTF-2017-LostKey/">Hack.lu CTF 2017 - LostKey</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-01-24T04:09:17.000Z" itemprop="datePublished">
    2018-01-24
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/reversing/">Reversing</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="Reversing"><a href="#Reversing" class="headerlink" title="Reversing"></a>Reversing</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( v10 &lt; <span class="number">4</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v3 = sub_8061250(esi0, <span class="number">8</span>);</span><br><span class="line">  *(_DWORD *)v3 = <span class="number">16</span> * v10 + <span class="number">135172200</span>;</span><br><span class="line">  *(_DWORD *)(v3 + <span class="number">4</span>) = *(_DWORD *)((<span class="keyword">char</span> *)&amp;tbyte_80E9000 + <span class="number">4</span> * v10 + a2 - <span class="number">135172092</span>);</span><br><span class="line">  esi0 = <span class="number">-4096</span> * (v10 + <span class="number">1</span>) + *(_DWORD *)byte_80E90B8 + dword_80EA3AC;</span><br><span class="line">  v4 = sub_807AE80((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))&amp;tbyte_80E9000, (<span class="keyword">int</span>)off_80E90A8[v10], esi0, <span class="number">273</span>, v3, v7, v8, v9);</span><br><span class="line">  sub_8078550(v4, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  sub_8061710(esi0, v3);</span><br><span class="line">  ++v10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4번 루프를 돌면서 argv[1] ~ argv[4]를 하나씩 검사한다. clone으로 자식 프로세스를 만들어서 검사하기 때문에 gdb의 set follow-fork-mode child를 통해 디버깅하였다. <br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( !ptrace(0, 0, 0) )</span><br><span class="line">&#123;</span><br><span class="line">  dword_80EA39C = 0x466C7578;</span><br><span class="line">  dword_80EA3A0 = 0x78756C46;</span><br><span class="line">  dword_80EA3A4 = 0x78756C46;</span><br><span class="line">  dword_80EA3A8 = 0x466C7578;</span><br><span class="line">&#125;</span><br><span class="line">retaddr = sub_804A1F0;</span><br></pre></td></tr></table></figure></p>
<p>특이한 점은 ptrace를 통해 key값을 설정해 argv[4]를 검사하는 루틴에서 사용하였고, rop로 연산이 진행되었다. 그래서 어셈블리 한줄씩 따라가면서 암호화 과정을 분석하였다. 처음 argv[1]은 그냥 key 값과 xor 한 후 비교하는 간단한 암호화였다. argv[1] == ‘flag{Th3’ <br><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encrypt</span></span><br><span class="line">argv[2] -&gt; '12345678abcdefgh'</span><br><span class="line"></span><br><span class="line">enc[<span class="number">0</span>]   = swapbit(!<span class="string">'1'</span> &amp; <span class="number">0xff</span>) ^ <span class="string">'2'</span></span><br><span class="line">enc[<span class="number">1</span>]   = swapbit(!<span class="string">'2'</span> &amp; <span class="number">0xff</span>) ^ <span class="string">'3'</span></span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">enc[n<span class="number">-1</span>] = swapbit(!<span class="string">'g'</span> &amp; <span class="number">0xff</span>) ^ <span class="string">'h'</span></span><br><span class="line">enc[n]   = swapbit(!<span class="string">'h'</span> &amp; <span class="number">0xff</span>) ^ <span class="string">'A'</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># decrypt</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">p = <span class="keyword">lambda</span> x:struct.pack(<span class="string">'I'</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enc</span><span class="params">(v)</span>:</span></span><br><span class="line">	t1 = v&lt;&lt;<span class="number">4</span></span><br><span class="line">	t2 = v&gt;&gt;<span class="number">4</span></span><br><span class="line">	<span class="keyword">return</span> (~((t1 | t2)&amp;<span class="number">0xff</span>))&amp;<span class="number">0xff</span></span><br><span class="line">table = [<span class="number">0x37d02c61</span>,<span class="number">0x63979f3b</span>,<span class="number">0xd07e4607</span>,<span class="number">0xad79934a</span>,<span class="number">0xddbdbbca</span>,<span class="number">0x64a669e7</span>]</span><br><span class="line">stable = <span class="string">''</span></span><br><span class="line">flag = <span class="string">'m'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">	stable += p(i)</span><br><span class="line"></span><br><span class="line">stable = stable[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(stable)):</span><br><span class="line">	flag += chr(enc(ord(stable[i]) ^ ord(flag[i])))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>argv[2] 암호화 과정을 간단하게 표현하면 코드이다. enc[n]에서는 무조건 ‘A’와 xor하기 때문에 뒤에서부터 역연산하여 두번째 flag 조각을 알아낼 수 있다. argv[2] == ‘_key_1s_in_th3_secret_com’ <br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v9 = __ROL4__(v171 + (i ^ v170 &amp; (i ^ v169)) + v6 - <span class="number">680876936</span>, <span class="number">7</span>);</span><br><span class="line">v10 = v9 + v170;</span><br><span class="line">v11 = *v5;</span><br><span class="line">++v5;</span><br><span class="line">v12 = v11;</span><br><span class="line">v13 = __ROL4__(i + (v169 ^ (v9 + v170) &amp; (v169 ^ v170)) + v8 - <span class="number">389564586</span>, <span class="number">12</span>);</span><br><span class="line">v14 = v13 + v10;</span><br><span class="line">v15 = *v5;</span><br><span class="line">++v5;</span><br><span class="line">v16 = v15;</span><br><span class="line">v17 = __ROL4__(v169 + (v170 ^ (v13 + v10) &amp; (v170 ^ v10)) + v12 + <span class="number">606105819</span>, <span class="number">17</span>);</span><br><span class="line">v18 = v17 + v14;</span><br><span class="line">v19 = *v5;</span><br><span class="line">++v5;</span><br><span class="line">v20 = v19;</span><br><span class="line">v21 = __ROL4__(v170 + (v10 ^ (v17 + v14) &amp; (v10 ^ v14)) + v16 - <span class="number">1044525330</span>, <span class="number">22</span>);</span><br><span class="line">v22 = v21 + v18;</span><br><span class="line">v23 = *v5;</span><br><span class="line">++v5;</span><br><span class="line">v24 = v23;</span><br><span class="line">v25 = __ROL4__(v10 + (v14 ^ (v21 + v18) &amp; (v14 ^ v18)) + v20 - <span class="number">176418897</span>, <span class="number">7</span>);</span><br><span class="line">v26 = v25 + v22;</span><br><span class="line">v27 = *v5;</span><br></pre></td></tr></table></figure></p>
<p>이제 argv[3]의 암호화 과정을 분석하기 위해 rwatch 명령어로 argv[3]에 브포를 걸고 연산하는 부분을 찾아가 보았더니, 상당히 복잡한 과정을 통해 암호화가 진행되었다. z3를 통해 해결하려고 했지만 암호화 과정을 처음부터 어셈으로 구현해서 그런지 hex-ray로 디컴파일된 소스가 정확하지 않았다. 알고보니 md5 hash과정을 어셈블리로 구현한 것임을 알고 hash killer를 통해 알아내었다. argv[3] == ‘p4rtme’<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( !ptrace(0, 0, 0) )</span><br><span class="line">&#123;</span><br><span class="line">  dword_80EA39C = 0x466C7578;</span><br><span class="line">  dword_80EA3A0 = 0x78756C46;</span><br><span class="line">  dword_80EA3A4 = 0x78756C46;</span><br><span class="line">  dword_80EA3A8 = 0x466C7578;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>프로세스마다 ptrace를 이용해 key값을 만들어주는데 마지막 argv[4]를 암호화할때 사용되었다. 처음에 key를 구하기 힘들어서 복호화를 못했는데 ida를 통해 모든 프로세스의 연산이 끝난 후에 key 값을 확인하여 정확한 key를 구하였다. 한번에 8byte씩 총 3번 암호화가 진행되었다. <br><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> str[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> table[] = &#123;<span class="number">0xa42d6ebf</span>, <span class="number">0xefe89e7</span>, <span class="number">0xaadd934d</span>, <span class="number">0x4e4e7f13</span>, <span class="number">0x8ec32ca9</span>, <span class="number">0x8559d4e9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> d,<span class="keyword">unsigned</span> <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ebx=<span class="number">0</span>,edi,esi,ecx,i;</span><br><span class="line">	edi = d;</span><br><span class="line">	esi = s;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">		ebx = ebx + <span class="number">0x9e3779b9</span>;</span><br><span class="line">		ecx = (esi &lt;&lt; <span class="number">4</span>) + <span class="number">0xc2e1faff</span>;</span><br><span class="line">		ecx = ecx ^ (esi + ebx);</span><br><span class="line">		ecx = ecx ^ ((esi&gt;&gt;<span class="number">5</span>) + <span class="number">0xfffae1c2</span>);</span><br><span class="line">		edi = ecx + edi;</span><br><span class="line">		ecx = edi;</span><br><span class="line">		</span><br><span class="line">		ecx = (ecx&lt;&lt;<span class="number">4</span>) + <span class="number">0xfffae1c2</span>;</span><br><span class="line">		ecx = ecx ^ (edi + ebx);</span><br><span class="line">		ecx = ecx ^ ((edi&gt;&gt;<span class="number">5</span>) + <span class="number">0xc2e1faff</span>);</span><br><span class="line">		</span><br><span class="line">		esi = esi + ecx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%x %x\n"</span>,edi,esi);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrypt</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> d, <span class="keyword">unsigned</span> <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> ebx,edi,esi,ecx,i;</span><br><span class="line">	edi = d;</span><br><span class="line">	esi = s;</span><br><span class="line">	ebx = <span class="number">0xc6ef3720</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">		ecx = edi;</span><br><span class="line">	</span><br><span class="line">		ecx = (ecx&lt;&lt;<span class="number">4</span>) + <span class="number">0xfffae1c2</span>;</span><br><span class="line">		ecx = ecx ^ (edi + ebx);</span><br><span class="line">		ecx = ecx ^ ((edi &gt;&gt; <span class="number">5</span>) + <span class="number">0xc2e1faff</span>);</span><br><span class="line">		esi = esi - ecx;</span><br><span class="line"></span><br><span class="line">		ecx = (esi &lt;&lt; <span class="number">4</span>) + <span class="number">0xc2e1faff</span> ;</span><br><span class="line">		ecx = ecx ^ (esi + ebx);</span><br><span class="line">		ecx = ecx ^ ((esi&gt;&gt;<span class="number">5</span>) + <span class="number">0xfffae1c2</span>);</span><br><span class="line">		edi = edi - ecx;</span><br><span class="line">		ebx = ebx - <span class="number">0x9e3779b9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	str[<span class="number">0</span>] = edi;</span><br><span class="line">	str[<span class="number">1</span>] = esi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">		decrypt(table[i*<span class="number">2</span>],table[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>rop로 구현된 암호화 과정을 c 소스로 바뀐 뒤 복호화하였다. argv[4] == ‘nt_of_your_t00l_sh3d…}’</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/01/09/HITCON-2017-Everlasting-Imaginative-Void/">HITCON 2017 - Everlasting Imaginative Void</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-01-09T09:51:28.000Z" itemprop="datePublished">
    2018-01-09
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/reversing/">Reversing</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _isoc99_scanf(&amp;aS, &amp;input, a3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hitcon&#123;%s&#125;\n"</span>, &amp;input);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main 소스를 확인해보면 flag를 입력받고 출력해주는 소스밖에 없다. flag를 검사하는 루틴이 생성자나 소멸자에 있을 수 있다고 생각해 init_array와 fini_array를 확인해보았다. 동적 디버깅 상태에서 fini_array를 확인해보면 .eh_frame 영역에 저장되었는 쉘코드의 주소가 들어가 있다. 쉘코드는 처음에 입력한 flag의 16번째 글자가 ‘!’일때 aesenc 명령어를 통해 aes 암호화를 진행하고 마지막에 ucomisd 명령어로 비교하는 코드였다.<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.eh_frame:0000564119ED085F mov     rsi, rbx</span><br><span class="line">.eh_frame:0000564119ED0862 sub     si, 0C7h</span><br><span class="line">.eh_frame:0000564119ED0867 add     rbx, 2007E1h</span><br><span class="line">.eh_frame:0000564119ED086E movdqu  xmm1, xmmword ptr [rbx]</span><br><span class="line">.eh_frame:0000564119ED0872 movdqu  xmm0, xmmword ptr [rsi]</span><br><span class="line">.eh_frame:0000564119ED0876 pxor    xmm1, xmm0</span><br><span class="line">.eh_frame:0000564119ED087A push    0Ah</span><br><span class="line">.eh_frame:0000564119ED087C pop     rdi</span><br><span class="line">.eh_frame:0000564119ED087D</span><br><span class="line">.eh_frame:0000564119ED087D loc_564119ED087D:                       ; CODE XREF: .eh_frame:0000564119ED0892j</span><br><span class="line">.eh_frame:0000564119ED087D add     rsi, 10h</span><br><span class="line">.eh_frame:0000564119ED0881 movdqu  xmm0, xmmword ptr [rsi]</span><br><span class="line">.eh_frame:0000564119ED0885 dec     edi</span><br><span class="line">.eh_frame:0000564119ED0887 test    edi, edi</span><br><span class="line">.eh_frame:0000564119ED0889 jz      short loc_564119ED0894</span><br><span class="line">.eh_frame:0000564119ED088B js      short loc_564119ED089B</span><br><span class="line">.eh_frame:0000564119ED088D aesenc  xmm1, xmm0</span><br><span class="line">.eh_frame:0000564119ED0892 jmp     short loc_564119ED087D</span><br><span class="line">.eh_frame:0000564119ED0894 ; ---------------------------------------------------------------------------</span><br><span class="line">.eh_frame:0000564119ED0894 loc_564119ED0894:                       ; CODE XREF: .eh_frame:0000564119ED0889j</span><br><span class="line">.eh_frame:0000564119ED0894 aesenclast xmm1, xmm0</span><br><span class="line">.eh_frame:0000564119ED0899 jmp     short loc_564119ED087D</span><br><span class="line">.eh_frame:0000564119ED089B ; ---------------------------------------------------------------------------</span><br><span class="line">.eh_frame:0000564119ED089B loc_564119ED089B:                       ; CODE XREF: .eh_frame:0000564119ED088Bj</span><br><span class="line">.eh_frame:0000564119ED089B ucomisd xmm0, xmm1</span><br><span class="line">.eh_frame:0000564119ED089F jz      short near ptr unk_564119ED08A2</span><br><span class="line">.eh_frame:0000564119ED08A1 retn</span><br></pre></td></tr></table></figure></p>
<p>위의 코드가 aes 암호화와 비교가 진행되는 부분의 쉘코드다. aes 암호화는 init round, 9번의 round, final round를 통해 암호화를 진행하는데 쉘코드도 aes의 암호화 루틴과 비슷하지만, 키를 생성하지 않고 bss영역에서 데이터를 불러와 키로 사용한다. 복호화를 하기 위해 aes instruction set에 대해 알아보았다. 키 생성은 aeskeygenassist 를 이용하고 암호화에는 aesenc, aesenclast 복호화에는 aesdec, aesimc, aesdeclast 를 사용한다.<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmm0 - plaintext</span><br><span class="line">xmm1~xmm11 - scheduled keys</span><br><span class="line">pxor xmm0, xmm1 /∗ Round 0 (whitening) ∗/</span><br><span class="line">aesenc xmm0, xmm2 /∗ Round 1 ∗/</span><br><span class="line">aesenc xmm0, xmm3 /∗ Round 2 ∗/</span><br><span class="line">aesenc xmm0, xmm4 /∗ Round 3 ∗/</span><br><span class="line">aesenc xmm0, xmm5 /∗ Round 4 ∗/</span><br><span class="line">aesenc xmm0, xmm6 /∗ Round 5 ∗/</span><br><span class="line">aesenc xmm0, xmm7 /∗ Round 6 ∗/</span><br><span class="line">aesenc xmm0, xmm8 /∗ Round 7 ∗/</span><br><span class="line">aesenc xmm0, xmm9 /∗ Round 8 ∗/</span><br><span class="line">aesenc xmm0, xmm10 /∗ Round 9 ∗/</span><br><span class="line">aesenclast xmm0, xmm11 /∗ Round 10 ∗/</span><br></pre></td></tr></table></figure></p>
<p>aes encrypt 과정을 어셈으로 구현한 코드다. 복호화에는 암호화에서 사용한 마지막 key가 첫번째 key가 되고, aesimc 명령어를 통해 inverse cipher key를 구해서 사용한다.<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global _start</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">key db 0x48,0xC1,0xFD,0x03,0xE8,0x07,0xFE,0xFF,0xFF,0x48,0x85,0xED,</span><br><span class="line">0x74,0x20,0x31,0xDB,0x0F,0x1F,0x84,0x00,0x00,0x00,0x00,0x00,0x4C,</span><br><span class="line">0x89,0xEA,0x4C,0x89,0xF6,0x44,0x89,0xFF,0x41,0xFF,0x14,0xDC,0x48,</span><br><span class="line">0x83,0xC3,0x01,0x48,0x39,0xDD,0x75,0xEA,0x48,0x83,0xC4,0x08,0x5B,</span><br><span class="line">0x5D,0x41,0x5C,0x41,0x5D,0x41,0x5E,0x41,0x5F,0xC3,0x90,0x66,0x2E,</span><br><span class="line">0x0F,0x1F,0x84,0x00,0x00,0x00,0x00,0x00,0xF3,0xC3,0x00,0x00,0x48,</span><br><span class="line">0x83,0xEC,0x08,0x48,0x83,0xC4,0x08,0xC3,0x00,0x00,0x00,0x01,0x00,</span><br><span class="line">0x02,0x00,0x25,0x73,0x00,0x68,0x69,0x74,0x63,0x6F,0x6E,0x7B,0x25,</span><br><span class="line">0x73,0x7D,0x0A,0x00,0x00,0x01,0x1B,0x03,0x3B,0x40,0x00,0x00,0x00,</span><br><span class="line">0x07,0x00,0x00,0x00,0xBC,0xFD,0xFF,0xFF,0x8C,0x00,0x00,0x00,0xCC,</span><br><span class="line">0xFD,0xFF,0xFF,0xB4,0x00,0x00,0x00,0xEC,0xFD,0xFF,0xFF,0x5C,0x00,</span><br><span class="line">0x00,0x00,0x1C,0xFF,0xFF,0xFF,0xCC,0x00,0x00,0x00,0x57,0xFF,0xFF,</span><br><span class="line">0xFF,0xEC,0x00,0x00,0x00,0x6C,0xFF,0xFF,0xFF,0x0C,0x01,0x00,0x00,</span><br><span class="line">0xDC,0xFF,0xFF,0xFF,0x54,0x01,0x00,0x00</span><br><span class="line"></span><br><span class="line">cipher db 0xE7,0x47,0x04,0x12,0x49,0x6D,0xCF,0x47,0xB0,0xE9,0x1B,</span><br><span class="line">0x17,0x67,0xFB,0x46,0x28</span><br><span class="line">plaintext db 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,</span><br><span class="line">0x00,0x00,0x00,0x00,0x00</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">_start:</span><br><span class="line">call decrypt</span><br><span class="line"></span><br><span class="line">decrypt:</span><br><span class="line">mov rax,cipher</span><br><span class="line">movdqu xmm15, [rax]</span><br><span class="line">mov rax,key</span><br><span class="line">add rax,0xa0</span><br><span class="line">movdqu xmm0, [rax]</span><br><span class="line">pxor xmm15, xmm0</span><br><span class="line"></span><br><span class="line">push 0xa</span><br><span class="line">pop rdi</span><br><span class="line"></span><br><span class="line">round:</span><br><span class="line">sub rax,0x10</span><br><span class="line">movdqu xmm0, [rax]</span><br><span class="line">dec edi</span><br><span class="line">test edi, edi</span><br><span class="line">jz declast</span><br><span class="line">js return</span><br><span class="line">aesimc xmm0, xmm0</span><br><span class="line">aesdec xmm15,xmm0</span><br><span class="line">jmp round</span><br><span class="line"></span><br><span class="line">declast:</span><br><span class="line">aesdeclast xmm15,xmm0</span><br><span class="line">jmp round</span><br><span class="line"></span><br><span class="line">return:</span><br><span class="line">mov rax,plaintext</span><br><span class="line">movdqu [rax],xmm15</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p>
<p>flag를 구하기 위해 작성한 복호화 어셈 코드다. bss 영역에 있는 key 데이터를 모두 가져오고, 뒤에서부터 16byte씩 가져와 사용하였다. plaintext에 저장된 데이터를 확인해보면 flag를 확인할 수 있다.<br><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># ./void </span></span><br><span class="line">code_in_BuildID!</span><br><span class="line">hitcon&#123;code_in_BuildID!&#125;</span><br><span class="line">Good!</span><br></pre></td></tr></table></figure></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2018/01/02/HITCON-2017-Seccomp/">HITCON 2017 - Seccomp</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2018-01-02T04:52:12.000Z" itemprop="datePublished">
    2018-01-02
  </time>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/reversing/">Reversing</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <h3 id="Write-up"><a href="#Write-up" class="headerlink" title="Write-up"></a>Write-up</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  main.c</span></span><br><span class="line">  v6 = <span class="number">4059</span>;</span><br><span class="line">  v7 = &amp;filter;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v8, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    _isoc99_scanf(<span class="string">"%llu"</span>, &amp;v8 + i);</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">if</span> ( prctl(<span class="number">22</span>, <span class="number">2L</span>L, &amp;v6) )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"prctl"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  syscall(<span class="number">4919L</span>L, v8, v9, v10, v11, v12, v13);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Excellent! flag: hitcon&#123;%s&#125;\n"</span>, &amp;v8);</span><br></pre></td></tr></table></figure>
<p>프로그램의 소스는 간단하다. 5개의 정수를 입력받고 seccomp 필터를 통해 검사를 진행한다. seccomp 필터의 길이가 무려 4059개이므로 툴의 힘을 빌려서 빠르게 분석해보자.<br><br></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># seccomp-tools dump ./seccomp </span></span><br><span class="line">1 2 3 4 5</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x15 0x01 0x00 0x00001337  <span class="keyword">if</span> (A == 0x1337) goto 0003</span><br><span class="line"> 0002: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0003: 0x20 0x00 0x00 0x00000010  A = args[0]</span><br><span class="line"> 0004: 0x07 0x00 0x00 0x00000000  X = A</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/david942j/seccomp-tools" target="_blank" rel="noopener">seccomp tool</a> 의 dump 기능을 이용하면 자동으로 seccomp 필터를 dump 시켜준다. dump한 필터를 보면 역시나 4058줄이나 된다. 문제 제작자도 이 코드를 한줄씩 한줄씩 직접 코딩하지 않고 특정 연산을 seccomp filter 문법으로 바꿔주는 스크립트를 통해 만들었다고 생각해 해당 필터의 패턴을 분석해보았다.<br><br></p>
<p>우선 입력한 5개의 정수가 차례대로 연산이 진행된다. args[0]~args[4]가 입력한 정수들이다. 정수는 16byte 나눠서 mem[0]~mem[3]에 들어가게 된다. mem[0]~mem[3]을 통해 복잡해보이는 연산을 거치고 마지막에 if문에서 검사를 한다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0017: 0x60 0x00 0x00 0x00000000  A = mem[0]</span><br><span class="line">0018: 0x15 0x00 0x01 0x00000000  if (A != 0) goto 0020</span><br><span class="line">0019: 0x00 0x00 0x00 0x00010000  A = 65536</span><br><span class="line">0020: 0x24 0x00 0x00 0x00006761  A *= 0x6761</span><br><span class="line">0021: 0x07 0x00 0x00 0x00000000  X = A</span><br><span class="line">0022: 0x34 0x00 0x00 0x00010001  A /= 0x10001</span><br><span class="line">0023: 0x24 0x00 0x00 0x00010001  A *= 0x10001</span><br><span class="line">0024: 0x84 0x00 0x00 0x00000000  A = -A</span><br><span class="line">0025: 0x0c 0x00 0x00 0x0000c450  A += X</span><br><span class="line">0026: 0x15 0x00 0x01 0x00010000  if (A != 65536) goto 0028</span><br><span class="line">0027: 0x00 0x00 0x00 0x00000000  A = 0</span><br><span class="line">0028: 0x02 0x00 0x00 0x00000000  mem[0] = A</span><br></pre></td></tr></table></figure>
<p>위의 연산은 A가 65536일 경우에 예외처리가 추가된 점을 빼면 곱셉 + mod 연산이다.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0029: 0x60 0x00 0x00 0x00000001  A = mem[1]</span><br><span class="line"> 0030: 0x04 0x00 0x00 0x00006c66  A += 0x6c66</span><br><span class="line"> 0031: 0x54 0x00 0x00 0x0000ffff  A &amp;= 0xffff</span><br><span class="line"> 0032: 0x02 0x00 0x00 0x00000001  mem[1] = A</span><br></pre></td></tr></table></figure>
<p>위의 연산은 변수에 정수를 더하는 연산은 표현한 것이다. 이처럼 add,mul,xor,swap 등의 연산을 모두 seccomp filter 문법으로 표현하였고 이런 패턴들이 계속 반복되었다. 그래서 정규식을 통해 이 패턴들을 모두 찾아서 1줄 코드로 바꿔보았다.<br><br></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#replace.py</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">data = open(<span class="string">'filter.txt'</span>,<span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line">pMULr = <span class="string">"""A = (mem\[\d\])</span></span><br><span class="line"><span class="string">A \*= (0x[0-9a-z]+)</span></span><br><span class="line"><span class="string">X = A</span></span><br><span class="line"><span class="string">A /= 0x10001</span></span><br><span class="line"><span class="string">A \*= 0x10001</span></span><br><span class="line"><span class="string">A = -A</span></span><br><span class="line"><span class="string">A \+= X</span></span><br><span class="line"><span class="string">(mem\[\d\]) = A</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pat  = re.compile(pMULr)</span><br><span class="line">data = pat.sub(<span class="string">"\g&lt;3&gt; = (\g&lt;1&gt;*\g&lt;2&gt;)%0x10001\n"</span>,data)</span><br><span class="line"></span><br><span class="line">pADDi = <span class="string">"""A = (mem\[\d\])</span></span><br><span class="line"><span class="string">A \+= (0x[0-9a-z]+)</span></span><br><span class="line"><span class="string">A &amp;= 0xffff</span></span><br><span class="line"><span class="string">(mem\[\d\]) = A</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pat  = re.compile(pADDi)</span><br><span class="line">data = pat.sub(<span class="string">"\g&lt;3&gt; = (\g&lt;1&gt;+\g&lt;2&gt;)&amp;0xffff\n"</span>,data)</span><br><span class="line"></span><br><span class="line">pADDv = <span class="string">"""A = (mem\[\d\])</span></span><br><span class="line"><span class="string">X = (mem\[\d\])</span></span><br><span class="line"><span class="string">A \+= X</span></span><br><span class="line"><span class="string">A &amp;= 0xffff</span></span><br><span class="line"><span class="string">(mem\[\d\]) = A</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pat  = re.compile(pADDv)</span><br><span class="line">data = pat.sub(<span class="string">"\g&lt;3&gt; = (\g&lt;1&gt;+\g&lt;2&gt;)&amp;0xffff\n"</span>,data)</span><br><span class="line"></span><br><span class="line">pXOR = <span class="string">"""A = (mem\[\d\])</span></span><br><span class="line"><span class="string">X = (mem\[\d\])</span></span><br><span class="line"><span class="string">A \^= X</span></span><br><span class="line"><span class="string">(mem\[\d\]) = A</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pat  = re.compile(pXOR)</span><br><span class="line">data = pat.sub(<span class="string">"\g&lt;3&gt; = \g&lt;1&gt;^\g&lt;2&gt;\n"</span>,data)</span><br><span class="line"></span><br><span class="line">pSWAP = <span class="string">"""A = (mem\[\d\])</span></span><br><span class="line"><span class="string">X = (mem\[\d\])</span></span><br><span class="line"><span class="string">mem\[\d\] = X</span></span><br><span class="line"><span class="string">mem\[\d\] = A</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pat  = re.compile(pSWAP)</span><br><span class="line">data = pat.sub(<span class="string">"\g&lt;1&gt;,\g&lt;2&gt; = \g&lt;2&gt;,\g&lt;1&gt;\n"</span>,data)</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'filter_a.txt'</span>,<span class="string">'w'</span>)</span><br><span class="line">f.write(data)</span><br></pre></td></tr></table></figure>
<p>filter.txt 에는 seccomp filter 코드들이 들어간다. 파이썬 스크립트를 통해 seccomp filter 문법에서 python 문법으로 모두 바꿨더니 코드양이 많이 줄어들고 반복적인 루틴이 나타났다.<br><br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mem[0] = (mem[0]*0x6761)%0x10001</span><br><span class="line">mem[1] = (mem[1]+0x6c66)&amp;0xffff</span><br><span class="line">mem[2] = (mem[2]+0x5f65)&amp;0xffff</span><br><span class="line">mem[3] = (mem[3]*0x6b61)%0x10001</span><br><span class="line">mem[4] = mem[0]^mem[2]				- (1)</span><br><span class="line">mem[5] = mem[1]^mem[3]</span><br><span class="line">mem[4] = (mem[4]*0x665f)%0x10001</span><br><span class="line">mem[5] = (mem[4]+mem[5])&amp;0xffff</span><br><span class="line">mem[5] = (mem[5]*0x615f)%0x10001</span><br><span class="line">mem[4] = (mem[4]+mem[5])&amp;0xffff</span><br><span class="line">mem[0] = mem[0]^mem[5]			    - (2)</span><br><span class="line">mem[1] = mem[1]^mem[4]</span><br><span class="line">mem[2] = mem[2]^mem[5]</span><br><span class="line">mem[3] = mem[3]^mem[4]</span><br><span class="line">mem[1],mem[2] = mem[2],mem[1]</span><br></pre></td></tr></table></figure>
<p>위와 같은 연산이 총 8번 진행되고(8번째에서는 swap 연산 제외), mul 연산과 xor 연산후에 if문을 통한 검사가 진행되었다. 전체 루틴을 정리하자면 처음에는 64byte 변수, args[0]이 mem[0]~mem[3]에 나누어 들어간다. 그리고 8번의 encrypytion을 진행하고 간단한 mul, xor 연산후에 검사한다.<br><br></p>
<p>args[0]을 구하기 위해 처음에는 z3를 통해 해결하려고 하였지만, 자꾸 unsat이 뜨고 if문 처리가 복잡해서 역연산하여 args[0]을 구해보았다. 역연산을 진행하다 보면 mem[4],mem[5]은 mem[0]~mem[3]과 달리 if문 검사를 안하기 때문에 값을 바로 알 수 없어 역연산이 매우 복잡해보인다. 그런데 (1)에서 mem[4] = mem[0]^mem[2] 이고, (2)에서 mem[0] = mem[0]^mem[5], mem[2] = mem[2]^mem[5] 이기 때문에 mem[4]의 값을 알아낼 수 있다. mem[0]^mem[2]를 하게 되면 mem[5]의 값이 0이 되면서 mem[4]과 똑같아 지는 것이다. 이 방법으로 mem[4],mem[5]의 값을 알아내면 된다. 그리고 mul 연산은 일차 합동식의 형태를 띄고 있으므로 역원을 구하는 과정을 거쳐야 한다(0x10001은 소수이므로 역원이 무조건 존재함).<br><br></p>
<h3 id="Solve-py"><a href="#Solve-py" class="headerlink" title="Solve.py"></a>Solve.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#solve.py</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> inverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Inverse</span><span class="params">(m,p)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">		m=<span class="number">65536</span></span><br><span class="line">	m = (m * inverse(p,<span class="number">0x10001</span>))%<span class="number">0x10001</span></span><br><span class="line">	<span class="keyword">if</span> m==<span class="number">65536</span>:</span><br><span class="line">		m=<span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MUL</span><span class="params">(m,v)</span>:</span></span><br><span class="line">	<span class="keyword">if</span> m==<span class="number">0</span>:</span><br><span class="line">		m=<span class="number">65536</span></span><br><span class="line">	m = (m*v)%<span class="number">0x10001</span></span><br><span class="line">	<span class="keyword">if</span> m==<span class="number">65536</span>:</span><br><span class="line">		m=<span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span><span class="params">(mem,v)</span>:</span></span><br><span class="line">	mem[<span class="number">1</span>],mem[<span class="number">2</span>] = mem[<span class="number">2</span>],mem[<span class="number">1</span>]</span><br><span class="line">	mem[<span class="number">4</span>] = mem[<span class="number">0</span>]^mem[<span class="number">2</span>]</span><br><span class="line">	mem[<span class="number">5</span>] = mem[<span class="number">1</span>]^mem[<span class="number">3</span>]</span><br><span class="line">	mem[<span class="number">4</span>] = MUL(mem[<span class="number">4</span>],v[<span class="number">4</span>])</span><br><span class="line">	mem[<span class="number">5</span>] = (mem[<span class="number">4</span>]+mem[<span class="number">5</span>])&amp;<span class="number">0xffff</span></span><br><span class="line">	mem[<span class="number">5</span>] = MUL(mem[<span class="number">5</span>],v[<span class="number">5</span>])</span><br><span class="line">	mem[<span class="number">4</span>] = (mem[<span class="number">4</span>]+mem[<span class="number">5</span>])&amp;<span class="number">0xffff</span></span><br><span class="line">	mem[<span class="number">3</span>] = mem[<span class="number">3</span>]^mem[<span class="number">4</span>]</span><br><span class="line">	mem[<span class="number">2</span>] = mem[<span class="number">2</span>]^mem[<span class="number">5</span>]</span><br><span class="line">	mem[<span class="number">1</span>] = mem[<span class="number">1</span>]^mem[<span class="number">4</span>]</span><br><span class="line">	mem[<span class="number">0</span>] = mem[<span class="number">0</span>]^mem[<span class="number">5</span>]</span><br><span class="line">	mem[<span class="number">3</span>] = Inverse(mem[<span class="number">3</span>],v[<span class="number">3</span>])</span><br><span class="line">	mem[<span class="number">2</span>] = (mem[<span class="number">2</span>]-v[<span class="number">2</span>])&amp;<span class="number">0xffff</span></span><br><span class="line">	mem[<span class="number">1</span>] = (mem[<span class="number">1</span>]-v[<span class="number">1</span>])&amp;<span class="number">0xffff</span></span><br><span class="line">	mem[<span class="number">0</span>] = Inverse(mem[<span class="number">0</span>],v[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">return</span> mem</span><br><span class="line"></span><br><span class="line">expression = open(<span class="string">'expression.txt'</span>,<span class="string">'r'</span>).read()</span><br><span class="line">regular = <span class="string">"""(mem\[0\] = \(mem\[0\]\*(0x[0-9a-z]+)\)%0x10001</span></span><br><span class="line"><span class="string">mem\[1\] = \(mem\[1\]\+(0x[0-9a-z]+)\)&amp;0xffff</span></span><br><span class="line"><span class="string">mem\[2\] = \(mem\[2\]\+(0x[0-9a-z]+)\)&amp;0xffff</span></span><br><span class="line"><span class="string">mem\[3\] = \(mem\[3\]\*(0x[0-9a-z]+)\)%0x10001</span></span><br><span class="line"><span class="string">mem\[4\] = mem\[0\]\^mem\[2\]</span></span><br><span class="line"><span class="string">mem\[5\] = mem\[1\]\^mem\[3\]</span></span><br><span class="line"><span class="string">mem\[4\] = \(mem\[4\]\*(0x[0-9a-z]+)\)%0x10001</span></span><br><span class="line"><span class="string">mem\[5\] = \(mem\[4\]\+mem\[5\]\)&amp;0xffff</span></span><br><span class="line"><span class="string">mem\[5\] = \(mem\[5\]\*(0x[0-9a-z]+)\)%0x10001</span></span><br><span class="line"><span class="string">mem\[4\] = \(mem\[4\]\+mem\[5\]\)&amp;0xffff</span></span><br><span class="line"><span class="string">mem\[0\] = mem\[0\]\^mem\[5\]</span></span><br><span class="line"><span class="string">mem\[1\] = mem\[1\]\^mem\[4\]</span></span><br><span class="line"><span class="string">mem\[2\] = mem\[2\]\^mem\[5\]</span></span><br><span class="line"><span class="string">mem\[3\] = mem\[3\]\^mem\[4\]</span></span><br><span class="line"><span class="string">mem\[1\],mem\[2\] = mem\[2\],mem\[1\])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">regular_end = <span class="string">"""mem\[0\] = \(mem\[0\]\*(0x[0-9a-z]+)\)%0x10001</span></span><br><span class="line"><span class="string">mem\[1\] = \(mem\[1\]\+(0x[0-9a-z]+)\)&amp;0xffff</span></span><br><span class="line"><span class="string">mem\[2\] = \(mem\[2\]\+(0x[0-9a-z]+)\)&amp;0xffff</span></span><br><span class="line"><span class="string">mem\[3\] = \(mem\[3\]\*(0x[0-9a-z]+)\)%0x10001</span></span><br><span class="line"><span class="string">END"""</span></span><br><span class="line"></span><br><span class="line">pat = re.compile(regular_end)</span><br><span class="line">v1,v2,v3,v4 = map(<span class="keyword">lambda</span> a:int(a,<span class="number">16</span>),pat.findall(expression)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">mem = [<span class="number">44702</span>,<span class="number">45409</span>,<span class="number">6003</span>,<span class="number">2695</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(mem)):</span><br><span class="line">	mem[i] ^= <span class="number">4919</span></span><br><span class="line"></span><br><span class="line">mem[<span class="number">3</span>] = Inverse(mem[<span class="number">3</span>],v4)</span><br><span class="line">mem[<span class="number">2</span>] = (mem[<span class="number">2</span>] - v3)&amp;<span class="number">0xffff</span></span><br><span class="line">mem[<span class="number">1</span>] = (mem[<span class="number">1</span>] - v2)&amp;<span class="number">0xffff</span></span><br><span class="line">mem[<span class="number">0</span>] = Inverse(mem[<span class="number">0</span>],v1)</span><br><span class="line">mem[<span class="number">1</span>],mem[<span class="number">2</span>] = mem[<span class="number">2</span>],mem[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">pat = re.compile(regular)</span><br><span class="line">results = pat.findall(expression)[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">	v = map(<span class="keyword">lambda</span> a:int(a,<span class="number">16</span>),r[<span class="number">1</span>:])</span><br><span class="line">	mem = round(mem,v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> mem[:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>expressio.txt 에는 처음 변수를 넣는 과정, if문 검사를 제외하고 8번째 루틴의 swap 연산을 추가한 코드가 들어간다. 정규식을 통해 8번 진행되는 encryption에서 사용하는 정수를 모두 뽑아오고 round 함수에서 역연산이 진행된다. args[0]~args[5] 까지 반복하면 flag를 구할 수 있다.</p>

      
    </div>
</article>

    </li>
  
</ul>


            <footer>
    <div>© 2016 - kirasys </div>
    <div>
    Powered by Hexo
    </div>
</footer>

        </div>
    </div>
</div>
<script src="/js/pager/dist/singlepager.js"></script>
<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>